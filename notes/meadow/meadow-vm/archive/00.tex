\documentclass{pamsbook}
\usepackage{mathptm,mydef-ams,amsfonts}
\usepackage{alltt}
%\renewcommand{\ttdefault}{txtt}

%\usepackage{MinionPro}

%\setlength\oddsidemargin{-1.5cm}
%\setlength\evensidemargin{-1.5cm}
%\setlength\textwidth{19.3cm}
%\addtolength\topmargin{-1cm}
%\addtolength\textheight{2cm}
%\addtolength\columnsep{0.2cm}
%\newtheorem{theorem}{Theorem}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\def\EE{\mbox{\eufm{}E}}1

\begin{document}

%\begin{center}
%{\Large\bf Meadow Event Processing Language: User Guide} \par \bigskip
%Cheoljoo Jeong (cjeongkr@gmail.com)
%\end{center}

\title{{\Large\bf{}Meadowview:  A Language for Coordinating Device
    Interactions}} 
\author{\normalsize Cheoljoo Jeong (cjeongkr@gmail.com)}
\date{\normalsize\today}
\maketitle

%% \begin{abstract}
%% The Meadowview (MV) is a programming language for describing concurrent 
%% reactive processes in agents. A reactive process is defined as a
%% computational entity which, upon the receipt of events, perform simple testing
%% of events, and generate events. The language can be used to  
%% filter, transform, and generate events. 
%% The language was designed mostly for the analysis and generation of
%% events. Therefore, it lacks common programming language features such as
%% recursion. We expect all 
%% compute-intensive tasks will be performed at the endpoints in the overall
%% universe of events. Upon an arrival of an event instance, a Meadowview program
%% defines what new events needs to be generated as a result of evaluating rules
%% that react to the event.

%% The language was designed with scalability in mind. So, any language constructs
%% which would require substantial CPU or memory resources was deliberately left
%% out. 
%% \end{abstract}


%% \section{Overview}
%% \subsection{Internet of Things} 
%% Since the advent of the Internet, more and more computational entities
%% have been getting connected to the network. They interact with each other
%% using many different communication methods. The impending arrival of Internet of
%% Things (IoT)~\cite{AIM10} suggests that the number of computational entities
%% which will be added to this web may explode dramatically. 

%% With all these devices added to the web, we want to interact with them. Most
%% of all, we need to read and write data on the devices. In addition to mere
%% data accesses, we may need to add some ``control logic'' which dictates how
%% these devices should interact. This control logic allows some simple
%% repetitive things to be done automatically. 

%% Let's consider a set of one thousand devices connected with one way or
%% another. Some status change in one device may trigger a sequence
%% of actions and reactions, which altogether accomplish a intended work for the
%% given status change. 

%% \subsection{The Meadow system}
%% The Meadow system is a software infrastructure which facilitate the
%% exchange of events, description of reactive processes, and adding callback
%% functions to events. Any event that are of interest to anyone 
%% can be  registered as a Meadow event. One can define a reactive process, which
%% is essentially a callback function to the event. 

%% This process will wake up when the event gets activated. The Meadow runtime
%% provides a infrastructure where such events are passed between processes using
%% the medium of messages. 

%% \subsection{The Meadowview language}
%% The Meadowview is a programming language for
%% describing events and processes. Occurrences of events, or event instances,
%% can schedule the execution of processes which are sensitive to those events. 
%% Execution of processes, which in turn can create new events. 
%% It is loosely
%% based on the Actors model of computation~\cite{Hewitt76,Clinger81,Agha86}
%% tailored to support the paradigm of event processing~\cite{CM12,EN11}.

%% \subsection{Benefits of Meadowview EPL}



%% \section{Comparison to Existing Technologies}
%% \subsection{Event-driven programming framework}
%% Event-driven programming, where a control flow is determined by firing and
%% reception of events, has a long history. Most notable examples
%% where event-driven programming is intensively exercised include the X Window
%% Systems and JavaScript. 

%% Recently, Twisted~\cite{JK13}, an event-driven network programming framework,
%% is getting popular. In some sense, MV-EPL shares the same spirit with
%% Twisted. 

%% \subsection{Actor model of computation}

%% \subsection{Autonomous intelligent agents}

%% \subsection{Workflow management systems}


%% \subsection{Hardware description languages}
%% HDLs (Hardware Description Languages), such as Verilog~\cite{Verilog2005} or
%% VHDL~\cite{VHDL2008}, have been heavily used in the industry in design and
%% verification of digital systems.  These languages are not only used for
%% specification of digital systems but also for their synthesis. In these
%% languages, a digital system, which is denoted by Verilog or VHDL code,  is
%% considered to be consist of processes which are reactive to event changes.

%% For example, 
%% {\small
%% \begin{verbatim}
%%   // the always process below wakes up whenever 
%%   // the variables a or b changes their values 
%%   // and executes the body of the process
%%   always @(a or b) begin
%%     c = a + b;
%%   end

%%   // the value change of c would trigger the 
%%   // following process again
%%   always @(c) begin
%%     d = ~c;
%%   end
%% \end{verbatim}
%% }

%% A HDL process can be viewed as a digital gate or a component with inputs and
%% outputs, which recomputes the output whenever the input changes. Some of the
%% components, such as flip-flops can store states. It is not rare that a large
%% HDL code describes billions of processes, which interact with each other. So,
%% HDL would be one of the most intensively-used event-driven paradigm.

%% The MV-EPL heavily depends on many concepts of HDLs.
%% In particular, we adopt event trigger/wait as a way of nonblocking
%% communication between processes. 

%% One major difference is that, while HDL event trigger/wait is used just to
%% transfer controls, MV-EPL event trigger/wait transfers both control and data
%% (payload). -- CDFG?


%% \subsection{Message Queues}
%% There has been a surge of interest in messaging systems. This is because in
%% the era of distributed computing, blocking communication can no longer be a
%% viable option. 

\section{Basic Concepts}

\subsection{Events}
An {\em event} represents a class of occurrences such as ``something has
happened'', ``state of an object has changes'', etc. One event is uniquely
distinguishable from each other.  
Events are first-class citizens in MV, meaning that events can be
created, deleted, named, and passed around inside an MV-EPL program through
as function calls arguments and return values. 

\subsection{Event types}
Each event has a type. An event type is either a scalar type or 
a structure type or an array type.
An event type essentially specifies which
values each instances of the event can have. 
An event type has a \bb{unique name} inside the Meadow system. 

\paragraph{DISCUSS: } Whether we support event types or not is a topic to
discuss. Either we can support static types (at the time of event definition,
a type must be associated) or we can support dynamic types (or latent types,
where event instances carry its type rather than events). 

\subsection{Event instances}
While an event means a class of occurrences, an {\em event instance}
is a specific occurrence of the event. In this literature, the terms, event
instance, event object, and event occurrence will be used interchangeably.

\subsection{Signals} AllJoyn only supports a weaker notion of events:
\ee{signals}.  A \bb{signal} can be thought of as a special case of events,
which has the ``void'' type. 

\subsection{Events and event instances}
In the programming language parlance, one can consider that an event is a {\em
  variable\/} while an event instance is the {\em value of the variable\/} at
a specific time. Like variables, an event can have a type, called an {\em
  event type\/}.  

One important difference between variables and events is
that a single variable has a single value at some specific time but an event
can have multiple event instances alive at a specific time. 

\subsection{Processes}
A {\em process\/} is a computational entity which reacts to events. A process
has a set of events to which it is sensitive. When at least one of these
events are triggered, the process is executed. The execution of a process can
perform computation and trigger a finite number of events.

\subsection{Devices}
A {\bf device\/} is an entity with a {\bf unique name} in the
entire universe of the Meadow system. A device is {\em a collection of
  processes\/}, which react to events.

\subsection{Variables}
All variables must be defined inside the process. Therefore, the lifetime 
of a variable is confined to one execution of the process where it is defined.
No variable can persist across different process executions. If you need to
preserve a value (or a ``state''), you need to store it outside of MV.


\subsection{Functions}
All functions must be defined so that there is no references outside
of its parameters -- i.e. they must be self-contained, free of side-effects.


\section{Processes}
%% \subsection{Defining event types}
%% A type of an event can be defined and can be used when defining events. 
%% An event type is either a scalar type, such as integers, or a composite
%% type, such as structures.
%% {\small
%% \begin{verbatim}
%%   type name_type = string;
%%   type order_type = struct {
%%     symbol : string;
%%     price : float;
%%     quantity: integer;
%%   };
%%   type order_array_type = array [10] of order_type;
%% \end{verbatim}
%% }

%% \subsection{Defining events}
%% To transform conceptual events into an computable entity, you
%% have to be able to ``name'' it. Event definition can be loosely considered as
%% a variable definition in conventional programming languages. However, unlike
%% variables, which can have only value at a given instance of time, the event
%% can have have multiple values (i.e. event instances) at the same instance of
%% time.

%% {\small
%% \begin{verbatim}
%%   event order_event {
%%     person : name_type;
%%     order : order_type;
%%     order_id : integer;
%%   };

%%   event ack_event {
%%     order_id : integer;
%%   };
%% \end{verbatim}
%% }

\subsection{Process specification}
A process specification is a code which describes the behavior of a reactive
process. A process specification consists of two parts: the
{\bf event list\/} and the {\bf process body\/}.  

\subsection{Event list}
The event list is a list of
names of events which will wake up the process. 

\subsection{Process body} The process body is a code
which will be executed when any event in the event list gets triggered -- that
is, any event instance of an event in the event list is generated.

\subsection{Example process specification}
The following is a simple process which wakes up whenever an event instance of
\verb+order_event+ is generated, it will trigger new events depending on the
value of the event instance.

\begin{verbatim}
  process handle_order_event(order_event order) {
    if (order.quantity > 10)
      -> large_order_event(order_event.quantity);
    else
      -> small_order_event(order_event.quantity);
  }
\end{verbatim}


%% \subsection{Defining agents}
%% An agent is a collection of processes.
%% {\small
%% \begin{verbatim}
%%   agent MyAgent {
%%     process handle_FTO_request(FTO_request ftoreq) {
%%       ...
%%     }
%%     process handle_PTO_request(PTO_request ptoreq) {
%%       ...
%%     }
%%   }
%% \end{verbatim}
%% }

\subsection{Event list specification}
There are three forms of event list allowed:
a single event (e.g. \verb+(event1 a)+), disjunction of events
(e.g. \verb+(event1 a OR event2 b)+), or
conjunction of events (e.g. \verb+(event1 a OR event2 b)+). 
More than two events in the event list are not allowed -- such cases can
be recoded using only two events in the list. 

\subsection{Process body specification}
The body of a process can be one of the following statements:
\verb+IF-THEN-ELSE+, \verb+FOR-LOOP+, \verb+TIMING+, 
\verb+EVENT-TRIGGER+, 
\verb+REMOTE-FUNC-CALL+. 

\subsection{Expressions}

\subsection{Statements}

\section{Examples of processes}
\subsection{Event filters}
An {\em event filter\/} is a special type of processes whose input events and output
events are the same. It is used to filter out some event instances which are
not interesting or useful. For example, the following process filter out all order
events whose quantity is 0. Event filters can be used in event window definition.
{\small
\begin{verbatim}
  filter postive_quantity(order_event o) {
    if (o.quantity > 0) {
      -> o;
    }
  }
  windows w0(order_event o) = {
    filter(positive_quantity);
    #5(events); // max 5 events
    @5(events); // max 5 seconds
  };
\end{verbatim}
}

\subsection{Event aggregators}
One can join two different events into one.
{\small
\begin{verbatim}
  window agg(order_event, cancel_event) = {
    -> (order_event, cancel_event)
  };
\end{verbatim}
}

\subsection{Event windows}
An \bb{event window} is a special type of processes which takes events as its
input and produces events as its output. Event windows are defined based on
the number of events which can be retained inside the window and/or the time
period. 
{\small
\begin{verbatim}
  window order_event_default_window(order_event) {
    // size-1 window with infinite interval; which is 
    // created implicity by default
    #1(events);
  }

  windows w0(order_event) = {
    #5(events); // max 5 events
    @5(events); // max 5 seconds
  };
\end{verbatim}
}


\section{Usages of Meadowview EPL}
\subsection{Building State Machines using Processes}
{\small
\begin{verbatim}
  process StateMachine(InputEvent e) {
    int state;
  
    switch (state) {
    case 0:
      if (e.value == 1)
        state = 1;
        -> OutputEvent(e.value + 1);
      else
        state = 2;
        -> OutputEvent(e.value + 2);
      break;
    case 1:
    }
  }
\end{verbatim}
}

\subsection{Describing workflow}
{\small
\begin{verbatim}
  process Process1(LaunchProcess1 e) {
    if (e.value == 2) {
      e.process1_finished = true;
      -> LaunchProcess2(e);
    }
    else if (e.value == 3) {
      e.process1_finished = true;
      -> LaunchProcess3(e);
    }
  }

  process Process2(LaunchProcess2 e) {
    -> Process4(e);
  }

  process Process3(LaunchProcess3 e) {
    -> Process4(e);
  }

  process Process4(LaunchProcess4 e) {
    // finish the workflow
    -> FlowFinished(e);
  }
}
\end{verbatim}




\section{Using Event Cloud}

\subsection{Users of event cloud}
By defining events and processes, we have built event highways. Now, the
question is how we can use this. There are two types of users of events and
processes: {\em event producers} and {\em event consumers}. 

\subsection{Event producers}
After an event is defined, say \verb+order_event+, one can generate its event
instances using event producer API in different languages. The following
example shows such an example in C++. 

{\small
\begin{verbatim}
  mv::Runtime *rt = mv::Runtime::getInstance();
  mv::Event *ev = rt->lookup("order_event");
  mv::EventIntanceArgs args;
  args.addArgument("symbol", "AMD");
  args.addArgument("price", 4.5);
  args.addArgument("quantity", 32);
  rt->createEventInsance(ev, args);
\end{verbatim}
}


\subsection{Event consumers}
Also, event consumers can register its callback to the event.
{\small
\begin{verbatim}
  mv::Runtime *rt = mv::Runtime::getInstance();
  mv::Event *ev = rt->lookup("order_event");
  // make it not copy-constructrable;
  // should be heap-alloc'd
  mv::EventListener *listener = rt->createListener();
  rt->addListener(ev, listener);
\end{verbatim}
}


\section{Event Types}

\subsection{Type definitions}



\section{Events}

\section{Processes}
\subsection{Processes sensitive to a single event}
Simpler processes are sensitive to a single event, as shown below.

{\small
\begin{verbatim}
  process classify_order(order_event order) {
    if (order_event.quantity > 10) {
      -> midsize_order_event(order_event.quantity);
    }
    else if (order_event.quantity > 100) {
      -> large_order_event(order_event.quantity);   
    }
    else {
      -> small_order_event(order_event.quantity);
    }
  }
}
\end{verbatim}
}

\subsection{Processes sensitive to multiple events}
A process can be sensitive to multiple events. In the example below, when at
least one of the three events are triggered, the process will be executed.

{\small 
\begin{verbatim}
  process p1(alices_value_changed e0, 
             bobs_value_changed e1) {
    if (e0.value  e1.value == e3.value) {
      -> value_sum_match_event(e0.value + e1.value);
    }
  }
\end{verbatim}
}

\subsection{Processes sensitive to event windows}
Processes can be sensitive to event windows.
{\small
\begin{verbatim}
  process p0(w0) {
    if (valid_order(w0.order)) {
      -> ack_event(create_order_id());
    }
  }
\end{verbatim}
}


\section{Event Producers}
\subsection{Event producer API}
Meadow library provides event producer APIs in many different programming
languages. 

\section{Event Consumers}
\subsection{Direct procedure call}
Inside the process, users can call a C or C++ function directly. 
{\small
\begin{verbatim}
  process @(ack_event) {
    // DPI call in C
    dpi_db_store(ack_table, ack_event.order_id, 
                 ack_event.date);
  }
\end{verbatim}
}

\section{Language Constructs}
\subsection{Namespace}
\begin{verbatim}
\end{verbatim}

\subsection{Device (a.k.a. Agents)}
A device is any entity which can either produce or consume events.

\subsubsection{Example} The following code defines a device which can
produce an event named \verb+button_pressed+.
\begin{verbatim}
  producer button {
    event {
      button_pressed;
    }
    action {
    }
  }
\end{verbatim}

\subsection{Event instances}
An event instance can be created using an event constructor.
{\small
\begin{verbatim} 
  order_event("cjeong", {"AMD", 3.80, 100}, 0)
\end{verbatim}
}

\bit
\w Exchange format can be XML, etc.
\eit

\subsection{Event patterns}
\bit
\w An \bb{event pattern} denotes a finite state machine, which generates
outputs from inputs.
\w Does this require stateful implementation?
\eit
{\small
\begin{verbatim} 
  pattern large_order(order_event e1) {
    e1.order.quantity > 100;
  }

  pattern chip_company_order(order_event e) {
    e.reqexp("AMD | INTC") == true;
  }

  pattern followed_by(order_event e1, 
                      cancel_event e2) {
    (e1.order_id == e2.order_id) and 
    (e1.date < e2.date);
  };
\end{verbatim}
}

\subsection{Event generation}
\bit
\w \bb{API}: some external application calls API function call for which
language binding exists
\w \bb{internal}

{\small
\begin{verbatim}  
  always @('5s) begin // time tick
    -> timegen(5sec_passed);
\end{verbatim}
}
\eit

\section{Implementation}
\bit
\w Oblivious computation
  \bit
  \w particular computation need not be executed at particular core,
  processor, machine
  \w code can be migrated very easily
  \w for this, we must not pass large data between sites
  \w need a uniform and distributed way to lookup things
  \w we may need a distributed memory, cache, or lookup/symbol table which
  produces a consistent and efficient way of storing commonly accessed data
  \eit
\eit
\subsection{Runtime}
\bit
\w pipelines
\w routers
\w all stages that consumes ev will wake up
\w routing plan (workflow) is generated for eve, where the plan is a
topological order of the work, where work is
   (processor, code) e.g. 
{\small
\begin{verbatim}
(pattern-detector, large_order_detect, e1)
\end{verbatim}
}

\eit

\subsection{Compiler}
\bit
\w A Hadoop-like work-distribution system will compile the code and generate
the code
\w generate code
  \bit
  \w process: seq of instructions that executes the code in proc body
  \w pattern: FSM in some format
  \w window: some primitives which can be executed to generate the event window
  \eit
\eit

\subsection{Stages}
\bit
\w kinds of stages
  \bit
  \w pattern detector
  \w window generator
  \w processor executor
  \w router
  \eit
\w components
  \bit
  \w code lookup table
  \w event lookup table
  \w event processor (which machine is responsible for event) lookup table
  \eit
\w each stage retrieves the arguments, and executes and puts the output result
\eit

\subsection{Event entry}
\bit
\w find the given event and insert
  \begin{verbatim}  
  Event ev = lookup(Event_id);
  insertEvent(ev);
  \end{verbatim}
\w put the event to the system
  \bit
  \w event ev is serialized (w/ known data layout) and put into address X
  \eit
\w (optional) rout the event to the relevant server
\eit


\subsection{Triggering events: Generating event instances}
\bit
\w calls API function: \verb+insertEvent(event_id, data)+
\w sends a data to a TCP/IP port
\eit

\subsection{Event windows}
\bit
\w Define some low-level primitive, universal set of operators and then define
high-level clauses (retain, slide, etc.) using these universal set.
\eit

\tableofcontents

\bibliographystyle{plain}
\bibliography{bib/mac,bib/softsys,bib/compsys,bib/digital,bib/pl}
\nocite{EN11,Agha86,Hewitt76,Verilog2005,JK13,SK09}
\nocite{LABHJJLTZ05,VD10}
\end{document}

%%  LocalWords:  MeadowView EPL Hadoop proc FSM API insertEvent TCP IP ev MV
%%  LocalWords:  Runtime workflow lookup Namespace stateful Meadow Jeong
%%  LocalWords:  Cheoljoo runtime HDLs Verilog VHDL HDL APIs softsys compsys
