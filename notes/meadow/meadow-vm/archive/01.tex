\documentclass{pamsbook}
\usepackage{mathptm,mydef-ams,amsfonts,courier}
\usepackage{alltt}
\usepackage[T1]{fontenc}
%\renewcommand{\ttdefault}{txtt}

%\usepackage{MinionPro}

%\setlength\oddsidemargin{-1.5cm}
%\setlength\evensidemargin{-1.5cm}
%\setlength\textwidth{19.3cm}
%\addtolength\topmargin{-1cm}
%\addtolength\textheight{2cm}
%\addtolength\columnsep{0.2cm}
%\newtheorem{theorem}{Theorem}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\def\EE{\mbox{\eufm{}E}}1

\begin{document}

\small

%\begin{center}
%{\Large\bf Meadow Event Processing Language: User Guide} \par \bigskip
%Cheoljoo Jeong (cjeongkr@gmail.com)
%\end{center}

\begin{center}
{\large\bf Meadow VM:  Virtual Machine for The Meadow System}
\\

\vspace*{0.8cm}

{\small\today}

\vspace*{0.8cm}

\end{center}



%\title{{\Large\bf{}Meadowview:  A Language for Coordinating Device
%    Interactions}} 
%\author{\normalsize Cheoljoo Jeong (cjeongkr@gmail.com)}
%\date{\normalsize\today}
%\maketitle


%% \subsection{The Meadow system}
%% The Meadow system is a software infrastructure which facilitate the
%% exchange of events, description of reactive processes, and adding callback
%% functions to events. Any event that are of interest to anyone 
%% can be  registered as a Meadow event. One can define a reactive process, which
%% is essentially a callback function to the event. 

%% This process will wake up when the event gets activated. The Meadow runtime
%% provides a infrastructure where such events are passed between processes using
%% the medium of messages. 

%% \subsection{The Meadowview language}
%% The Meadowview is a programming language for
%% describing events and processes. Occurrences of events, or event instances,
%% can schedule the execution of processes which are sensitive to those events. 
%% Execution of processes, which in turn can create new events. 
%% It is loosely
%% based on the Actors model of computation~\cite{Hewitt76,Clinger81,Agha86}
%% tailored to support the paradigm of event processing~\cite{CM12,EN11}.

%% \subsection{Benefits of Meadowview EPL}



%% \section{Comparison to Existing Technologies}
%% \subsection{Event-driven programming framework}
%% Event-driven programming, where a control flow is determined by firing and
%% reception of events, has a long history. Most notable examples
%% where event-driven programming is intensively exercised include the X Window
%% Systems and JavaScript. 

%% Recently, Twisted~\cite{JK13}, an event-driven network programming framework,
%% is getting popular. In some sense, MV-EPL shares the same spirit with
%% Twisted. 

%% \subsection{Actor model of computation}

%% \subsection{Autonomous intelligent agents}

%% \subsection{Workflow management systems}


%% \subsection{Hardware description languages}
%% HDLs (Hardware Description Languages), such as Verilog~\cite{Verilog2005} or
%% VHDL~\cite{VHDL2008}, have been heavily used in the industry in design and
%% verification of digital systems.  These languages are not only used for
%% specification of digital systems but also for their synthesis. In these
%% languages, a digital system, which is denoted by Verilog or VHDL code,  is
%% considered to be consist of processes which are reactive to event changes.

%% For example, 
%% {\small
%% \begin{verbatim}
%%   // the always process below wakes up whenever 
%%   // the variables a or b changes their values 
%%   // and executes the body of the process
%%   always @(a or b) begin
%%     c = a + b;
%%   end

%%   // the value change of c would trigger the 
%%   // following process again
%%   always @(c) begin
%%     d = ~c;
%%   end
%% \end{verbatim}
%% }

%% A HDL process can be viewed as a digital gate or a component with inputs and
%% outputs, which recomputes the output whenever the input changes. Some of the
%% components, such as flip-flops can store states. It is not rare that a large
%% HDL code describes billions of processes, which interact with each other. So,
%% HDL would be one of the most intensively-used event-driven paradigm.

%% The MV-EPL heavily depends on many concepts of HDLs.
%% In particular, we adopt event trigger/wait as a way of nonblocking
%% communication between processes. 

%% One major difference is that, while HDL event trigger/wait is used just to
%% transfer controls, MV-EPL event trigger/wait transfers both control and data
%% (payload). -- CDFG?


%% \subsection{Message Queues}
%% There has been a surge of interest in messaging systems. This is because in
%% the era of distributed computing, blocking communication can no longer be a
%% viable option. 

\section{Introduction}
\noindent{}The Meadow VM is a virtual machine with is capable of executing
\bb{processes}
%\footnote{Actually, a task is very similar to an always process in
%  Verilog. The reason why the word `task' is used is to avoid 
%  confusion since the term process is heavily-overloaded. Note that non-EDA people has a bit different notion of {\em
%    processes\/} than that of EDA verification.} 
reactive to events.  

\section{Basic Concepts}

\subsection{Events}
An {\em event} represents a class of occurrences such as ``something has
happened'', ``state of an object has changes'', etc. 
%One event is uniquely distinguishable from each other.
Each event has a \bb{name}, which is globally unique in the entire Meadow
system. 

%% Events are first-class citizens in MV, meaning that events can be
%% created, deleted, named, and passed around inside an MV-EPL program through
%% as function calls arguments and return values. 

\subsection{Event types}
Every event has a type. An {\em event type} is either a scalar type, 
a structure type, or an array type.
An event type specifies the
values which instances of the corresponding event can have. 
Each event type has a \bb{name} which is globally unique in the Meadow
system.\footnote{Which event types to support is a
  topic to discuss. Either we can support static types (at the time of event
  definition, a type must be associated) or we can support dynamic types (or
  latent types, where event instances carry its type rather than events).}

\subsection{Event instances}
While an event means a class of occurrences, an {\em event instance}
is a specific occurrence of the event. In this document, the terms, {\em event
instance\/}, {\em event object\/}, and {\em event occurrence\/} will be used
interchangeably. 

\subsection{Method invocation and signals}
The Meadow VM doesn't support the notion of method invocation and
signals. Instead, we simulate these notions using the notion of events. The
next two sections will elaborate this.\footnote{The notions of \bb{method
  invocation} and \bb{signals} can be best explained by the Unix system call and
  Unix signals. When a user program wants to get a service from a
  kernel, the user program actively calls the system call (PULL). Signals
  are another way for user programs to get a service from system call. Now, we
  provide function to be invoked by the kernel when some event happens
  (PUSH). 

  One big different between PULL and PUSH that, in the former, the servicee
  knows exactly when it needs service. In the latter, 
}


\subsection{Events vs method invocations} 
%AllJoyn only supports a weaker notion of events: \ee{signals}.  A \bb{signal} can be thought of as a special case of events,
%which has the ``void'' type. 
%Events are a more general notion than method invocations and signals
%in the sense the latter notions can be simulated using events. 
A method invocation in a distributed system consists two separate events: 1)
an request event generated by the caller  and is delivered to the callee, and
2) a reply event generated by the callee and is delivered to the caller. 
The first event carries arguments as its payload and the second event carries
(optional) return value as it payload.

\subsection{Events vs signals}
The notion of signals is very close to that of events. The only difference is
that the payload carried by signals are limited while events support payload
with complex types. 
%The fact that signal is generated itself conveys information that ``something
%has happened''.  

\subsection{Events and event instances}
In the programming language parlance, one can consider that an event is a {\em
  variable\/} while an event instance is the {\em value of the variable\/} at
a specific time. Like variables, an event can have a type, called an {\em
  event type\/}.  

One important difference between variables and events is
that a single variable has a single value at some specific time but an event
can have multiple event instances alive at a specific time. 

\subsection{Processes}
A {\em process\/} is a computational entity which reacts to events. A process
has a event\footnote{Note that a process is only sensitive to one event. Note
  that this definition can support more complicated situations. First, let a
  process wake up when both event $A$ and event $B$ occurs. Then, we can create
  four processes and two events. always @(A) halfEnabledA = 1; always @(B)
  halfEnabledB = 1; always @(B) if (halfEnabledA) AB; always @(A) if
  (halfEnabledB) AB;} to which it is sensitive. When the given event occurs,
the task is executed. A task can only perform finite number of
primitive operations.

\subsection{Primitive operations}
A {\em primitive operation\/} is an operation  that can be natively executed
by the Meadow VM. Only a small set of operations are allowed:
\bb{variable definition}, \bb{branching}, \bb{assignment}, \bb{foreign
  function call}, and \bb{event generation\/}.  Each of these operations will
be discussed in detail in a later section. 


%% \subsection{Devices}
%% A {\bf device\/} is an entity with a {\bf unique name} in the
%% entire universe of the Meadow system. A device is {\em a collection of
%%   processes\/}, which react to events.

\subsection{Variables}
A {\em variable\/} in the typical sense is also supported in the Meadow VM.
The scope of a variable is the VM where the variable is defined. 
That is, a variable defined in a task can be accessed from any task in the
same VM. Also, a VM cannot access a variable defined in a different
VM.

Note that a {\em variable\/} is a way to model the notion of \bb{state}. 
By limiting the scope of a variable to a single VM, we
effectively remove the globally-maintained state. Supporting the notion of
global state may not be {\em scalable\/}.

%% All variables must be defined inside the process. Therefore, the lifetime 
%% of a variable is confined to one execution of the process where it is defined.
%% No variable can persist across different process executions. If you need to
%% preserve a value (or a ``state''), you need to store it outside of MV.


%% \subsection{Functions}
%% All functions must be defined so that there is no references outside
%% of its parameters -- i.e. they must be self-contained, free of side-effects.


\section{Namespaces}


\section{Processes}

\subsection{Process specification}
A process specification is a code which describes the behavior of a reactive
process. A process specification consists of two parts: the
{\bf event\/} and the {\bf task body\/}.  

\subsection{Event list}
The event list is a list of
names of events which will wake up the process. 

\subsection{Process body} The process body is a code
which will be executed when any event in the event list gets triggered -- that
is, any event instance of an event in the event list is generated.

\subsection{Example process specification}
The following is a simple process which wakes up whenever an event instance of
\verb+order_event+ is generated, it will trigger new events depending on the
value of the event instance.

\begin{verbatim}
  process handle_order_event(order_event order) {
    if (order.quantity > 10)
      -> large_order_event(order_event.quantity);
    else
      -> small_order_event(order_event.quantity);
  }
\end{verbatim}


%% \subsection{Defining agents}
%% An agent is a collection of processes.
%% {\small
%% \begin{verbatim}
%%   agent MyAgent {
%%     process handle_FTO_request(FTO_request ftoreq) {
%%       ...
%%     }
%%     process handle_PTO_request(PTO_request ptoreq) {
%%       ...
%%     }
%%   }
%% \end{verbatim}
%% }

\subsection{Event list specification}
There are three forms of event list allowed:
a single event (e.g. \verb+(event1 a)+), disjunction of events
(e.g. \verb+(event1 a OR event2 b)+), or
conjunction of events (e.g. \verb+(event1 a OR event2 b)+). 
More than two events in the event list are not allowed -- such cases can
be recoded using only two events in the list. 

\subsection{Process body specification}
The body of a process can be one of the following statements:
\verb+IF-THEN-ELSE+, \verb+FOR-LOOP+, \verb+TIMING+, 
\verb+EVENT-TRIGGER+, 
\verb+REMOTE-FUNC-CALL+. 

\subsection{Expressions}

\subsection{Statements}

\section{Examples of processes}
\subsection{Event filters}
An {\em event filter\/} is a special type of processes whose input events and output
events are the same. It is used to filter out some event instances which are
not interesting or useful. For example, the following process filter out all order
events whose quantity is 0. Event filters can be used in event window definition.
{\small
\begin{verbatim}
  filter postive_quantity(order_event o) {
    if (o.quantity > 0) {
      -> o;
    }
  }
  windows w0(order_event o) = {
    filter(positive_quantity);
    #5(events); // max 5 events
    @5(events); // max 5 seconds
  };
\end{verbatim}
}

\subsection{Event aggregators}
One can join two different events into one.
{\small
\begin{verbatim}
  window agg(order_event, cancel_event) = {
    -> (order_event, cancel_event)
  };
\end{verbatim}
}

\subsection{Event windows}
An \bb{event window} is a special type of processes which takes events as its
input and produces events as its output. Event windows are defined based on
the number of events which can be retained inside the window and/or the time
period. 
{\small
\begin{verbatim}
  window order_event_default_window(order_event) {
    // size-1 window with infinite interval; which is 
    // created implicity by default
    #1(events);
  }

  windows w0(order_event) = {
    #5(events); // max 5 events
    @5(events); // max 5 seconds
  };
\end{verbatim}
}


\section{Usages of Meadowview EPL}
\subsection{Building State Machines using Processes}
{\small
\begin{verbatim}
  process StateMachine(InputEvent e) {
    int state;
  
    switch (state) {
    case 0:
      if (e.value == 1)
        state = 1;
        -> OutputEvent(e.value + 1);
      else
        state = 2;
        -> OutputEvent(e.value + 2);
      break;
    case 1:
    }
  }
\end{verbatim}
}

\subsection{Describing workflow}
{\small
\begin{verbatim}
  process Process1(LaunchProcess1 e) {
    if (e.value == 2) {
      e.process1_finished = true;
      -> LaunchProcess2(e);
    }
    else if (e.value == 3) {
      e.process1_finished = true;
      -> LaunchProcess3(e);
    }
  }

  process Process2(LaunchProcess2 e) {
    -> Process4(e);
  }

  process Process3(LaunchProcess3 e) {
    -> Process4(e);
  }

  process Process4(LaunchProcess4 e) {
    // finish the workflow
    -> FlowFinished(e);
  }
}
\end{verbatim}




\section{Using Event Cloud}

\subsection{Users of event cloud}
By defining events and processes, we have built event highways. Now, the
question is how we can use this. There are two types of users of events and
processes: {\em event producers} and {\em event consumers}. 

\subsection{Event producers}
After an event is defined, say \verb+order_event+, one can generate its event
instances using event producer API in different languages. The following
example shows such an example in C++. 

{\small
\begin{verbatim}
  mv::Runtime *rt = mv::Runtime::getInstance();
  mv::Event *ev = rt->lookup("order_event");
  mv::EventIntanceArgs args;
  args.addArgument("symbol", "AMD");
  args.addArgument("price", 4.5);
  args.addArgument("quantity", 32);
  rt->createEventInsance(ev, args);
\end{verbatim}
}


\subsection{Event consumers}
Also, event consumers can register its callback to the event.
{\small
\begin{verbatim}
  mv::Runtime *rt = mv::Runtime::getInstance();
  mv::Event *ev = rt->lookup("order_event");
  // make it not copy-constructrable;
  // should be heap-alloc'd
  mv::EventListener *listener = rt->createListener();
  rt->addListener(ev, listener);
\end{verbatim}
}


\section{Event Types}

\subsection{Type definitions}



\section{Events}

\section{Processes}
\subsection{Processes sensitive to a single event}
Simpler processes are sensitive to a single event, as shown below.

{\small
\begin{verbatim}
  process classify_order(order_event order) {
    if (order_event.quantity > 10) {
      -> midsize_order_event(order_event.quantity);
    }
    else if (order_event.quantity > 100) {
      -> large_order_event(order_event.quantity);   
    }
    else {
      -> small_order_event(order_event.quantity);
    }
  }
}
\end{verbatim}
}

\subsection{Processes sensitive to multiple events}
A process can be sensitive to multiple events. In the example below, when at
least one of the three events are triggered, the process will be executed.

{\small 
\begin{verbatim}
  process p1(alices_value_changed e0, 
             bobs_value_changed e1) {
    if (e0.value  e1.value == e3.value) {
      -> value_sum_match_event(e0.value + e1.value);
    }
  }
\end{verbatim}
}

\subsection{Processes sensitive to event windows}
Processes can be sensitive to event windows.
{\small
\begin{verbatim}
  process p0(w0) {
    if (valid_order(w0.order)) {
      -> ack_event(create_order_id());
    }
  }
\end{verbatim}
}


\section{Event Producers}
\subsection{Event producer API}
Meadow library provides event producer APIs in many different programming
languages. 

\section{Event Consumers}
\subsection{Direct procedure call}
Inside the process, users can call a C or C++ function directly. 
{\small
\begin{verbatim}
  process @(ack_event) {
    // DPI call in C
    dpi_db_store(ack_table, ack_event.order_id, 
                 ack_event.date);
  }
\end{verbatim}
}

\section{Language Constructs}
\subsection{Namespace}
\begin{verbatim}
\end{verbatim}

\subsection{Device (a.k.a. Agents)}
A device is any entity which can either produce or consume events.

\subsubsection{Example} The following code defines a device which can
produce an event named \verb+button_pressed+.
\begin{verbatim}
  producer button {
    event {
      button_pressed;
    }
    action {
    }
  }
\end{verbatim}

\subsection{Event instances}
An event instance can be created using an event constructor.
{\small
\begin{verbatim} 
  order_event("cjeong", {"AMD", 3.80, 100}, 0)
\end{verbatim}
}

\bit
\w Exchange format can be XML, etc.
\eit

\subsection{Event patterns}
\bit
\w An \bb{event pattern} denotes a finite state machine, which generates
outputs from inputs.
\w Does this require stateful implementation?
\eit
{\small
\begin{verbatim} 
  pattern large_order(order_event e1) {
    e1.order.quantity > 100;
  }

  pattern chip_company_order(order_event e) {
    e.reqexp("AMD | INTC") == true;
  }

  pattern followed_by(order_event e1, 
                      cancel_event e2) {
    (e1.order_id == e2.order_id) and 
    (e1.date < e2.date);
  };
\end{verbatim}
}

\subsection{Event generation}
\bit
\w \bb{API}: some external application calls API function call for which
language binding exists
\w \bb{internal}

{\small
\begin{verbatim}  
  always @('5s) begin // time tick
    -> timegen(5sec_passed);
\end{verbatim}
}
\eit

\section{Implementation}
\bit
\w Oblivious computation
  \bit
  \w particular computation need not be executed at particular core,
  processor, machine
  \w code can be migrated very easily
  \w for this, we must not pass large data between sites
  \w need a uniform and distributed way to lookup things
  \w we may need a distributed memory, cache, or lookup/symbol table which
  produces a consistent and efficient way of storing commonly accessed data
  \eit
\eit
\subsection{Runtime}
\bit
\w pipelines
\w routers
\w all stages that consumes ev will wake up
\w routing plan (workflow) is generated for eve, where the plan is a
topological order of the work, where work is
   (processor, code) e.g. 
{\small
\begin{verbatim}
(pattern-detector, large_order_detect, e1)
\end{verbatim}
}

\eit

\subsection{Compiler}
\bit
\w A Hadoop-like work-distribution system will compile the code and generate
the code
\w generate code
  \bit
  \w process: seq of instructions that executes the code in proc body
  \w pattern: FSM in some format
  \w window: some primitives which can be executed to generate the event window
  \eit
\eit

\subsection{Stages}
\bit
\w kinds of stages
  \bit
  \w pattern detector
  \w window generator
  \w processor executor
  \w router
  \eit
\w components
  \bit
  \w code lookup table
  \w event lookup table
  \w event processor (which machine is responsible for event) lookup table
  \eit
\w each stage retrieves the arguments, and executes and puts the output result
\eit

\subsection{Event entry}
\bit
\w find the given event and insert
  \begin{verbatim}  
  Event ev = lookup(Event_id);
  insertEvent(ev);
  \end{verbatim}
\w put the event to the system
  \bit
  \w event ev is serialized (w/ known data layout) and put into address X
  \eit
\w (optional) rout the event to the relevant server
\eit


\subsection{Triggering events: Generating event instances}
\bit
\w calls API function: \verb+insertEvent(event_id, data)+
\w sends a data to a TCP/IP port
\eit

\subsection{Event windows}
\bit
\w Define some low-level primitive, universal set of operators and then define
high-level clauses (retain, slide, etc.) using these universal set.
\eit

\tableofcontents

\bibliographystyle{plain}
\bibliography{bib/mac,bib/softsys,bib/compsys,bib/digital,bib/pl}
\nocite{EN11,Agha86,Hewitt76,Verilog2005,JK13,SK09}
\nocite{LABHJJLTZ05,VD10}
\end{document}

%%  LocalWords:  MeadowView EPL Hadoop proc FSM API insertEvent TCP IP ev MV
%%  LocalWords:  Runtime workflow lookup Namespace stateful Meadow Jeong VM
%%  LocalWords:  Cheoljoo runtime HDLs Verilog VHDL HDL APIs softsys compsys
%%  LocalWords:  worklets worklet callee Namespaces FUNC aggregators pamsbook
%%  LocalWords:  Meadowview servicee halfEnabledA halfEnabledB
