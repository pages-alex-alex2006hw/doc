0. IoT: Assumptions
   a. There are huge number of DEVICES in the world.
   b. More DEVICES will get connected to the network.
   c. More DEVICES will have substantial computational capability --
      e.g. at least x86 capability, enough to run Linux.
   d. DEVICES are more useful when they cooperate
      => Billion dollar question: EXAMPLES(?!!!)
   e. Describing (or programming) cooperation between independent, autonomous
      DEVICES is difficult.
      => When we program a task performed by N heterogeneous devices,
         current technology allows people develop code from N different
         viewpoint.
      => Can we do this from a single viewpoint? Then, we can synthesize
         individual functionality, and then deploy them to N devices.

1. DEVICE is an autonomous computational entity, which can serve
   outside world through
   a. native properties,
   b. native events, and
   c. native functions

2. MEADOW DEVICE is an autonomous computational entity, which can
   serve outside world through
   a. properties (pull-based data which represent "state" of the device)
      - passive data which is used from external request
   b. events (push-based data, generated and sent to anyone who showed
      interest by subscription)
      - active data which is sent to outside by itself
   c. functions (pull-based functionality)
      - passive computation initiated by external request
   d. reactors (self-running )
      - active

   GOOD AUTOMATA (self-running engine)
     - record system
       - free spinning
     -
   HOW TO MERGE
     - 5 free-spinning wheels
     - just add wires to connect them 
     - add another free-spinning wheel (adding "SV interface")
       => new IDIOM

3. MEADOW SYSTEM provides a namespace of
   a. devices    - persistent (DB)
   b. VMs        - persistent (DB)
   c. processes  - persistent (DB)
   d. properties
   e. events
   f. reactors

   = NOTE: events have persistent names (unique ID) but 
           event instances does not have persistent names
           - they 
   = ID: 32bit metainfo + 96 bit for id
   = metainfo
     10-bits:  device, property, event, reactor, etc.
     
   = ID to LOC mapping
     (128-bit -> 128-bit + alpha)
                 for IPv6-addr

4. MEADOW RUNTIME (on each MEADOW DEVICE) allows to dynamically
   a. add/remove/update properties/events/functions/reactors
      (e.g. add-property)

      - add-function(funcname, function)
        -- internally, create an event "funcname-request"
        -- create a reactor on "funcname-request" which executes the function
   c. evaluates (executes) functions
      when they are invoked locally or remotely

4. MEADOW RUNTIMEs are responsible for
   a. providing an abstraction of "VM group"
      - should we use P2P overlay network?
      - can we use "multicasting"?
   b. add/remove/update group of VMs
   c. per-group capability (event, property, functions, etc.)

4. MEADOW RUNTIMEs are reponsible for
   a. delivering events between producers and consumers
      - maybe use ZeroMQ?

4. MEADOW RUNTIMEs allows to
   a. connect DEVICEs which support different framework
      (Google, Apple, AllJoyn, and)

5. PROCESS COMPILER
   - input


Splitting
  1. framework/API
     - apple
     - google
     - alljoyn

  2. benchmarks
     - ROS
     - Scala/Akka
     - Erlang
     - OPC
     - Hadoop/Pig/...
     - Dandelion
     - Workflow Systems
     - TinyOS/nesC
     - Web Services (also REST)
     - Distributed Objects (CORBA/Spring)

  3. Foundational technology
     - P2P
     - Security
     - 

  4. Practince
     - rlswng: 
       find use-cases: how to use
       find good IOT examples
       field request-type of new functionality/features

Meadow runtime
  - MV core
  - VM group
  - event-delivery on top of ZMQ
  - also, can talk AllJoyn, Google, Apple API, OCI(?)

Meadow Process layer
  - add notion of processes
  - maintains processes in the form of "another virtual device?"
    => virtual device is "SV intf" which connects participating devices
  - process lanugage compiler

The Meadow System
  - maintains namespace by dictionary lookup service
  - 


docs
  1. language guide
     - core
     - process definition

  2. meadow vm
     - API
     - capabilities
       - heterogeneous infra-hookup
         - add-foreign-function
       - device native capability
         - builtin-events
           - vm_runtime_started
             (so that, when new-persistent-prop is added, we can add
              new reactor which initializes it's value)
           - vm_event_received
           - vm_function_requested 
         - builtin-properties
         - add-property
         - add-persistent-property  (survives reboots)
         - add-persistent-reactor
       - VM group

  3. meadow system
     - VM
     - compiler
     - process layer
     - dictionaries
  
   
competing technologies
  - Java VM
    => Java instructions are too-low-level
    => consider Vlog simulator running RTL design vs gate-level design
       Java VM runs gate-level design
       Meadow VM runs RTl design (faster, also, code-side is smaller)

  - ROS
    => 

  - Erlang
    => no persistent namespaces
    => only languages not a system
    => also, no "property"
    => no notion of process synthesis

  - Scala/Akka
    => Java-based -- i.e. slow
    => 

  - TinyOS/nesC
    => we need full OS
    => full OS device will be the mainstream


Technical Challenges
  - we also want MV runtime to run on Arduino (at least Arduino Mega)
    can we make it that small?
 
Business Challenges
  - how to make money?
  - open-source or closed-source?  why?
 
