%\documentclass{pamsbook}\usepackage{mathptm,mydef-ams,amsfonts}
\documentclass{note}\usepackage{mathptm,mydef}
%\usepackage{courier}
\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[all,knot]{xy}
%\usepackage{MinionPro}
%\renewcommand{\ttdefault}{txtt}

\usepackage{hyperref}
\hypersetup{
    colorlinks, 
    citecolor=black, 
    filecolor=black,
    linkcolor=blue, 
    urlcolor=black
}

%\setlength\oddsidemargin{-1.5cm}
%\setlength\evensidemargin{-1.5cm}
%\setlength\textwidth{19.3cm}
%\addtolength\topmargin{-1cm}
%\addtolength\textheight{2cm}
%\addtolength\columnsep{0.2cm}
%\newtheorem{theorem}{Theorem}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\def\EE{\mbox{\eufm{}E}}1


\begin{document}

\small

\begin{center}
\textcolor{blue2}{\large\bf Meadowview: Language Guide}
\\
$$\xy
%\vtop{\vbox{
\xygraph{!{0;/r0.7pc/:} !{\vover}[u]
  !{\hcap[-2]} [d] !{\vover-} [ruu] !{\hcap[2]}}
%}\smallskip}
\endxy$$

\vspace*{0.8cm}

{\small\today}

\vspace*{0.8cm}

\end{center}



\section{Introduction}
\noindent{}The \textcolor{blue2}{\bf{}Meadowview (MV)} is a language for
describing individual or collective behavior of \textcolor{blue2}{\bf{}Meadow
  devices}. 
It is a dynamically-typed, statically-scoped language with type inference,
which facilitates {\em event-based, reactive programming model\/}.

\section{Basic Types}
\noindent{}Meadowview programs manipulate \bb{values}, where
{each value has a {\bf type}\/}. Unlike C++ or Java, where
variables have types, Meadowview is a dynamically-typed language.

\subsection{Scalar vs Aggregate Types}
A type is either a \bb{scalar type} or an \bb{aggregate type}.


\subsection{Booleans}
A boolean is a truth value, which can be either true or false.
\begin{alltt}
  \textcolor{red2}{true
  false}
\end{alltt}

\subsection{Integers}
\begin{alltt}
  \textcolor{red2}{2014  
  0
  -10}
\end{alltt}

\subsection{Real numbers}
\begin{alltt}
  \textcolor{red2}{3.14   
  0.0   
  -13.0   
  1E6   
  -1.3E-8}
\end{alltt}

\subsection{Time}
\begin{alltt}
  \textcolor{red2}{05-13-2014/23:11:10
  Aug-3-2014/00:00:00.000012
  }
\end{alltt}

\subsection{Characters}
\begin{alltt}
  \textcolor{red2}{'a'
  'b'
  #13}
\end{alltt}


\subsection{Symbols}
A \bb{symbol} is a value which presents the ``name'' of the symbol.
\begin{alltt}
  \textcolor{red2}{symbol
  com.mv.dataserver
}
\end{alltt}


\subsection{Strings}
A \bb{string} is a finite sequence of characters witch fixed length and thus
represent arbitrary Unicode texts.
\begin{alltt}
  \textcolor{red2}{"abc"
  "Program Transformation"
  }
\end{alltt}

\subsection{Pairs}
A \bb{pair} is a aggregate data with two components. 
\begin{alltt}
  \textcolor{red2}{(1, 3)
  sym = (a, "bc")
  sym.first    // a
  sym.second   // "bc"
  }
\end{alltt}

\subsection{Lists}
\begin{alltt}
  \textcolor{red2}{[1, 2, 3],
  sym = [1, 2, (3, "str"), [a.b, b.c]]
  sym.head     // 1
  sym.tail     // [2, (3, "str"), [a.b, b.c]]
}
\end{alltt}

\subsection{Vectors}
\begin{alltt}
  \textcolor{red2}{#[1, 2, 3]
  sym = #[10, 20, 30, "a"]
  sym[2]      // 30
}
\end{alltt}

\subsection{Named maps}
\begin{alltt}
  \textcolor{red2}{\{ name => "John", age => 25\}
  sym = \{ first => 1, second = "str" \}
  sym.first     // 30
}
\end{alltt}

\subsection{Events}
An \textcolor{blue2}{\bb{event}} is an aggregate data which is transferred
between devices.  An event supports operations such as 
\textcolor{red2}{\texttt{event\_publish}}
and
\textcolor{red2}{\texttt{event\_wait}}.
Events are treated as {\em first-class citizens\/} in Meadowview, meaning that
they can be passed as a function argument, returned from a function call, or
assigned to a variable.

Technically, an event is a named map with following predefined entries:
\bit
\w \textcolor{red2}{\texttt{event\_uuid}}: symbol
\w \textcolor{red2}{\texttt{device\_uuid}}: symbol
\w \textcolor{red2}{\texttt{timestamp}}: value of date type
\eit
Examples are:
\begin{alltt} 
  \textcolor{red2}{// constructor
  EV(com.mv.orderCompleteEvent, \{price => 100.34\})

  // event generation
  sym = EV(com.mv.orderCompleteEvent, \{price => 10\})
  event\_publish(sym)

  // event reception
  reactor (com.mv.orderCompleteEvent e) \{
    e.ev_uuid
    e.value
  \}
}
\end{alltt}
   

%An event is basically a named map, which a special tag 
%\verb+event_class+. 

%% \subsection{Event Classes}
%% An \bb{event class} is a dot-separated, hierarchical symbol,
%% e.g. \verb+com.meadow.ShippingNotice+. 
%% It denotes a globally-unique class of events, which itself is
%% a set of event fields. An event field is a symbol.

\subsection{Devices}
A \textcolor{blue2}{\bb{device}} is an entity which can offer services --
properties, events,  functions, and reactors.
In particular, device can be the target of 
standard functions such as
\verb+prop_get+, \verb+prop_set+, and \verb+call+ and \verb+call_async+.
%\textcolor{red2}{\texttt{send}} and
%\textcolor{red2}{\texttt{receive}}.

\begin{alltt}
  \textcolor{red2}{
  // no constructor
  // only bound when process is instantiated
}
\end{alltt}

Technically, a device is a named map with following predefined entries:
\bit
\w \textcolor{red2}{\texttt{device\_uuid}}: symbol
\eit


%% \subsection{Device Classes}
%% A \bb{device class} is a dot-separated, hierarchical symbol,
%% e.g. \verb+com.apple.iphone.4s+. 
%% It denotes a globally-unique class of devices, which itself
%% is a set of device fields. A device field is a symbol.


\subsection{Functions}
Functions are first-class citizens in Meadowview.
A \textcolor{blue2}{\textbf{function}} consists of {\em function parameters\/}
and the {\em function body\/}. 
%When a process is instantiated

\begin{alltt}
  \textcolor{red2}{function foo(a, b) \{
    return a + b;
  \}
}
\end{alltt}

\subsection{Reactors}
\subsection{Event reactors}
A \textcolor{blue2}{\textbf{reactor}} consists of an {\em event\/}, to
which the reactor are sensitized to, and the {\em reactor body\/}. 
The body of the reactor is executed whenever the event is triggered.
\begin{alltt}
  \textcolor{red2}{reactor R(com.mv.shippingNotice notice) \{
    a = notice.timestamp
    b = notice.data
  \}}
\end{alltt}

\subsection{Timed reactors}
\begin{alltt}
  \textcolor{red2}{timed_reactor R(\textrm{\arc{time}}]) \{
    a = notice.timestamp
    b = notice.data
  \}}
\end{alltt}

\subsection{Processes}
A \textcolor{blue2}{\textbf{process}} consists of 
{\em process parameters\/} and a collection of {\em reactors\/} and {\em
functions\/}. When a process is executed, reactors and functions will be
executed.\footnote{Actually, MV code
contains {\em process definitions} rather than {\em processes}. In this
document, the terms ``process definition'' and ``process'' will be used
interchangeably but it should be clear from the context which is referred
to.} 
\begin{alltt}
  \textcolor{red2}{process P(dev1, dev2) \{
    property ntransfers = 0;

    reactor consumer(dev1:dataReady e) \{
      data = dev1:get_data();
      dev2:consume_data(data);
      ntransfers++;
    \}

    function getTransfers() { return ntransfers; }
  \}}

  \textcolor{red2}{process ButtonAndLight(toggleButton, light) \{
    reactor consumer(toggleButton:pressed e) \{
      if (e.buttonOn)
        light:turnOn();
      else 
        light:turnOff();
    \}
  \}}

  \textcolor{green2}{process MapReduce(deviceList) \{
    HOW TO REPRESENT MAP REDUCE OR GRAPH WORK
  \}}
\end{alltt}

\section{Functions}
\subsection{Overview}
A \bb{function} is a piece of paramterized code.

\subsection{Syntactic form}
The following is the syntactic form of a function.
\begin{alltt}
  \textcolor{red2}{function \textrm{\arc{function\_name}}(\textrm{\arc{args}}) \{
    \textrm{\arc{function\_body}}
  \}}
\end{alltt}
where \arc{function\_body} consists of zero or more statements.

\subsection{Example}
\begin{alltt}
  \textcolor{red2}{function foo(x) \{
    return x + 1;
  \}}
\end{alltt}

%\subsection{Namespace of function names}
%The name of a function is unique in the entire space of names.
%Note that each process defines a unique namespace.

%\subsection{First-class functions}

\section{Reactors}
\subsection{Overview}
A \bb{reactor} is a piece of code parameterized by an {\em event\/},
which is invoked whenver the correponding event occurs. 
\bit
\w \bb{Q}: should we allow multiple events? if yes, is it ``OR'' or ``AND''
\w \bb{Q}: how can we support ``JOIN'' behavior?
\eit

\subsection{Syntactic form}
The following is the syntactic form of a reactor.
\begin{alltt}
  \textcolor{red2}{reactor \textrm{\arc{reactor\_name}}(\textrm{\arc{event\_class}} \textrm{\arc{event\_name}}) \{
    \textrm{\arc{reactor\_body}}
  \}}
\end{alltt}
In the form, \arc{reactor\_name}, \arc{event\_class}, and \arc{event\_name}
are \bb{symbols}.

\subsection{Semantics}
A reactor will be evaluated whenever an event of the event class, 
\arc{event\_class}, is generated. The given event value will be bound to 
the \arc{event\_name}. 

\subsection{Example}
\begin{alltt}
  \textcolor{red2}{reactor {myreactor}(com.mv.shipper:ShippingNotice notice) \{
    customerid = notice.customerid;
    trackid = notice.trackingId;
    func_call_async(com.mv.mailserver, sendmail, customerid, trackid);
    event\_publish(shippingDone);
  \}}
\end{alltt}

\subsection{Use of event class}
While meadowview is a dynamically-typed language, we still need
include the class of event when specifying a reactor.
This is to ensure only events of the given class will wake
up the reactor. Without event class, each reactor have to wake up 
on event of any event class.

%% \subsection{Deployment-time checking}
%% When the reactor is deployed to the device runtime 
%% using the built-in function \textcolor{red2}{\texttt{loadProcess}},
%% the \arc{event\_class} will be checked in the global distributed environment
%% which is maintained by all the device runtimes.

%% \subsection{Run-time checking}
%% The body of the reactor may contains operators over the event value
%% which is bound during evaluation. Whether the given operator
%% is valid (e.g. given event contains the used field) will be checked
%% during run-time.


\section{Processes}
\subsection{Syntactic form}
The following is the syntactic form of a reactor.
\begin{alltt}
  \textcolor{red2}{process \textrm{\arc{process\_name}}(\textrm{\arc{device\_class}} \textrm{\arc{device\_name}}) \{
    \textrm{\arc{process\_body}}
  \}}
\end{alltt}
In the form, \arc{process\_name}, \arc{device\_class}, and \arc{device\_name}
are \bb{symbols}.
The \arc{process\_body} can contain definitions of 
  {\em properties\/}, 
  {\em events\/}, 
  {\em functions\/}, and {\em reactors\/}.

\subsection{Example}
\begin{alltt}
  \textcolor{red2}{process com.mv.monitorTemperature(com.device.Thermostat dev) \{
    property batteryLife;    // pulled data
    event batteryLow;        // pushed data
    event needMaintenance;   // pushed data
   
    // ? need a way to import functions, properties, and events
    native function getTemperature();
    native function getBatteryLife();
    native event com.device.Thermostat:needMaintenance;

    function isBatteryMoreThanHalfFull() \{
      return (batteryLife > 0.5) ? true : false;
    \}

    // relay
    reactor ThermostatWatcher(com.device.Thermostat:needMaintenance e) \{
      :generate(needMaintenance(e.getReason() /* string */));
    \}

    function checkBatteryLoop() \{ 
      sleep(30*3600*1000 /* 30 minutes */);
      batteryLife = getBatteryLife();
      if (batteryLife < 0.2) \{
        :generate(batteryLow);
      \}
      checkBatteryLoop();
    \}

    // on process instantiation
    function \textbf{start}() \{
      checkBatteryLifeLoop();
    \}

    // on process instantiation and VM reboot
    function \textbf{init}() \{
    \}
  \}}
\end{alltt}

\subsection{Process names}
Process name must be unique over the entire name space. This will be
enforced during compilation of process.

\subsection{Events}
Events are values contained in a process.
Events are special class of values, which can be \bb{pushed} across 
processes.

\subsection{Properties}
Properties are values contained a process.
Properties are special class of values which can be \bb{pulled} across
processes. 


\subsection{Compilation of processes}
While reactors are interpreted by the device runtime but processes are
compiled by the process compiler. 
After compilation of the process, it can be instantiated multiple times with
device parameters.
Note that {\em \arc{event\_class}} is just another symbol, 

\subsection{Instantiation of processes}
When class of devices ``conform to'' (who performs conformance check?)
\arc{device\_class}'s of a process definition, the process can be instantiated
using the devices as actuals to the process definition. Process instantiation
amounts to {\em deploying the 
  process to the devices until this process is decomissioned\/}. 

\subsection{Lieftime of a process}
Process is alive until 
\bit
\w it is explicitly decomissioned.
\w \verb+kill-process+ builtin function is executed by a participating device.
\eit

\subsection{Execution of processes}
Instantiation of a process does not automatically execution of the process.
The process will begin execution when mandatory \verb+start+ function of the
process is executed.

\subsection{Non-native exports}
A process can contain non-native exports. An export is either an \bb{event}, a
\bb{property}, or a \bb{function}.\footnote{just like AllJoyn}

Q: how to integrate these notions? native exports vs non-native exports defined
by process definitions.

\subsection{The \texttt{start} function}
Every process definition must contain the definition of \verb+start+ function.

\subsection{The \texttt{initial} function}
An optional \verb+initial+ function is executed once in the following occasions.
\ben
\w When the process is first instantiated and deployed to a device, the device
runtime executes the initial process.
\w When the device boots, it executes all intial functions of the processes
which have been deployed to the device.
\een

\subsection{The \texttt{final} function}
An optional \verb+final+ is executed when the process is dismissed from the
device.

\subsection{Dismissal of processes}
A process can be a one-time process or a repetitive process. A one-time
process is dismissed from the device to which it is deployed whenever the
first termination condition is satisfied.


\section{Expressions}
\noindent{}An expression is a syntactic entity, which {\em evaluates to a
  value\/}. 

\subsection{Time}
\subsection{Variable references}
\subsubsection{List entry reference}
\subsubsection{Vector entry reference}
\subsubsection{Named map entry reference}

\subsection{Arithmetic expressions}

\subsection{Property References}
A property reference has the form
\begin{alltt}
  \textcolor{red2}{\textrm{\arc{device\_name}}:\textrm{\arc{property\_name}}}
\end{alltt}

\subsection{Function calls}
\begin{alltt}
  \textcolor{red2}{\textrm{\arc{device\_name}}:\textrm{\arc{function\_name}}(\textrm{\arc{args}})}
\end{alltt}


\section{Statements}
A function or a reactor consists of statements.

\subsection{Sequence}
\begin{alltt}
  \textcolor{red2}{\textrm{\arc{statement}} ; 
  \textrm{\arc{statement}}}
\end{alltt}
The ``\textcolor{red2}{\texttt{;}}'' is a sequencing operator which indicates
that the statement that comes before this operator is executed to its
completion, and then, the statement that comes after the operator is executed
to its completion.

\subsection{Parallel-fork}
\begin{alltt}
  \textcolor{red2}{fork \{
    \textrm{\arc{statement}}
    \textrm{\arc{statement}}
  \} \textrm{[}join \textrm{|} join_none \textrm{|} join_any \textrm{]}}
\end{alltt}
For now, the difference between sequence and parallel-fork is  that, when a
statement in a parallel-fork is suspended due to request to an external
device, the other statement in the fork can be executed.

\subsection{Assignments}
\begin{alltt}
  \textcolor{red2}{\textrm{\arc{lhs\_expr}} = \textrm{\arc{rhs\_expr}}}
\end{alltt}
where \textcolor{red2}{\textrm{\arc{lhs\_expr}}} is either a variable
or a device property. 


%% \subsection{Property get/set}
%% A local or remote property can be read or written using the following:
%% \begin{alltt}
%%   \textcolor{red2}{prop\_get(\textrm{\arc{device\_name}} \textrm{\arc{property\_name}}, \textrm{\arc{value}}) [: timeout \textrm{\arc{time}} => \{ \textrm{\arc{fail\_body}} \}}];
%%   \textcolor{red2}{prop\_set(\textrm{\arc{device\_name}} \textrm{\arc{property\_name}}, \textrm{\arc{value}}) [: timeout \textrm{\arc{time}} => \{ \textrm{\arc{fail\_body}} \}}];
%% \end{alltt}

\subsection{Event trigger}
\begin{alltt}
  \textcolor{red2}{=> EV(\textrm{\arc{event\_name}}, \textrm{\arc{event\_payload}})}
\end{alltt}

\subsection{Function calls}
A function call has the following synctactic form.
\begin{alltt}
  \textcolor{red2}{\textrm{\arc{device\_name}}:\textrm{\arc{function\_name}}(\textrm{\arc{args}}) \{
    timeout \textrm{\arc{time}} => \{ 
      \textrm{\arc{timeout\_body}} 
    \}
    failure => \{
      \textrm{\arc{failure\_body}} 
    \}
  \}}
\end{alltt}
The \arc{function\_name} is a symbol which notes the function to be invoked.
It can be either a local function or a remote function.
An optional \arc{fail\_body} can be executed in case the result is not
available in given timeout time.
This is mostly for remote procedure calls.

The $\arc{device\_name}$ can be \verb+local+ is the callee is defined inside
the same device.

%% \subsection{Nonblocking function calls}
%% \begin{alltt}
%%   \textcolor{red2}{call\_async(\textrm{\arc{device\_name}} \textrm{\arc{function\_name}}, \textrm{\arc{args}}) [: timeout \textrm{\arc{time}} => \{ \textrm{\arc{fail\_body}} \}];
%% }

%%   // find a way to add a reactor for response!
%% \end{alltt}

\subsection{Branches}
\begin{alltt}
  \textcolor{red2}{if (\textrm{\arc{cond}}) \{
    \textrm{\arc{statements}}
  \}
  else \{
    \textrm{\arc{statements}}
  \}}
\end{alltt}

\subsection{Loops}
\begin{alltt}
  \textcolor{red2}{for (\textrm{\arc{init}}; \textrm{\arc{cond}}; \textrm{\arc{step}}) \{
    \textrm{\arc{statements}}
  \}}
\end{alltt}
The \textrm{\arc{statements}} can contain \textcolor{red2}{\texttt{}continue}
or \textcolor{red2}{\texttt{}break} statement.


\section{Standard Library}

%% \subsection{Properties}
%% \subsubsection{\textcolor{red2}{\texttt{prop\_get}}}
%% \subsubsection{\textcolor{red2}{\texttt{prop\_set}}}

%% \subsection{Events}
%% \subsubsection{\textcolor{red2}{\texttt{event\_publish}}}
%% \subsubsection{\textcolor{red2}{\texttt{event\_subscribe}}}
%% \subsubsection{\textcolor{red2}{\texttt{event\_unsubscribe}}}
%% \subsubsection{\textcolor{red2}{\texttt{event\_wait}}}
%% \begin{alltt}
%%   event_wait
%% \end{alltt}

%% \subsection{Functions}
%% \subsubsection{\textcolor{red2}{\texttt{func\_call}}}
%% \subsubsection{\textcolor{red2}{\texttt{func\_call\_async}}}
%% \subsubsection{\textcolor{red2}{\texttt{func\_get\_arity}}}
%% \subsubsection{\textcolor{red2}{\texttt{func\_get\_ith\_type}}}


\subsection{Devices}
\subsubsection{\small\textcolor{red2}{\texttt{device\_self}}}
Returns the device where this function is executed.

\subsubsection{\small\textcolor{red2}{\texttt{device\_find}}}

\subsubsection{\small\textcolor{red2}{\texttt{device\_has\_function}}}

\subsubsection{\small\textcolor{red2}{\texttt{device\_has\_event}}}

\subsubsection{\small\textcolor{red2}{\texttt{device\_has\_property}}}

\subsubsection{\small\textcolor{red2}{\texttt{device\_alive\_p}}}


\subsection{Strings}
\subsubsection{\small\textcolor{red2}{\texttt{string\_find}}}
\subsubsection{\small\textcolor{red2}{\texttt{string\_concat}}}



\section{MVIR}
MVIR is an object code which is generated by Meadow compiler and is the native
code executed by the runtime.

\begin{verbatim}
  REACTOR_BEGIN R1 EVENT
  REACTOR_END R1

  ASSIGN LHS RHS
  CALL FUNCNAME ARGS
  IF COND B1 B2

  BLOCK_BEGIN B1  // basic block
  BLOCK_END B1

  ADD DEST SRC1 SRC2
  SUB DEST SRC1 SRC2

  FUNCTION_BEGIN F1 
  FUNCTION_END F1

  
  
  // special forms
  EVENT_ADD
  EVENT_REM
  PROP_ADD
  PROP_DEL
\end{verbatim}

\subsection{Arithmetic/Logic}
\subsection{Branching}
\subsection{Branching}


%\tableofcontents

%\bibliographystyle{plain}
%\bibliography{bib/mac,bib/softsys,bib/compsys,bib/digital,bib/pl}
\end{document}
