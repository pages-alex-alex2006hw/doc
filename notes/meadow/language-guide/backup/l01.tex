\documentclass{note}
\usepackage{mathptm,mydef,courier}
\usepackage{MinionPro}
\usepackage{alltt}
\usepackage[T1]{fontenc}
%% \newcommand\rbackslash{\symbol{`\\}}
%% \newcommand\rlbrace{\symbol{`\{}}
%% \newcommand\rrbrace{\symbol{`\}}}
%% \newcommand\bbackslash{{\bf\symbol{`\\}}}
%% \newcommand\blbrace{{\bf\symbol{`\{}}}
%% \newcommand\brbrace{{\bf\symbol{`\}}}}

\usepackage{hyperref}
\hypersetup{
    colorlinks, 
    citecolor=black, 
    filecolor=black, 
    linkcolor=blue, 
    urlcolor=black
}

%\renewcommand{\ttdefault}{txtt}

%\setlength\oddsidemargin{-1.5cm}
%\setlength\evensidemargin{-1.5cm}
%\setlength\textwidth{19.3cm}
%\addtolength\topmargin{-1cm}
%\addtolength\textheight{2cm}
%\addtolength\columnsep{0.2cm}
%\newtheorem{theorem}{Theorem}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\def\EE{\mbox{\eufm{}E}}1

\begin{document}
\small

\title{\large\bf \textcolor{blue2}{Meadowview:  A Language for Programmig
    Device Collaboration}}  
%\author{\normalsize Cheoljoo Jeong (cjeongkr@gmail.com)}
%\date{\normalsize\today}
\date{}
\maketitle

\section{Introduction}
%% Since the advent of the Internet, more and more computational entities
%% have been getting connected to the network. They interact with each other
%% using many different communication methods. The impending arrival of Internet 
%% of Things (IoT)~\cite{AIM10} suggests that the number of computational
%% entities which will be added to this web may explode dramatically. 

%% With all these devices added to the web, we want to interact with them. Most
%% of all, we need to read and write data on the devices. Also, we want to
%% perform some inherent functionality provided by the device, e.g. turn on the
%% coffee machine. In all, we need to add some ``control logic'' which dictates
%% how these devices should interact. This control logic allows some simple
%% repetitive things to be done automatically. 
%% Consider a set of one thousand devices connected with one way or
%% another. Some status change in one device may trigger a sequence
%% of actions and reactions, which altogether accomplish a intended work for the
%% given status change. 

%% \paragraph{The Meadowview programming language}
The \textcolor{blue2}{\bf{}Meadowview (MV)} is a programming language for
describing and coordinating devices in \textcolor{blue2}{\bf{}the Meadow
  system}. It consists of two parts -- {\em interface definition language\/}
and {\em workflow definition language\/}. The \textcolor{blue2}{\bf{}interface 
  definition language (IDL)} allows to define the service interface of devices 
while \textcolor{blue2}{\bf{}workflow definition language (WDL)} allows to
define how devices interact to accomplish a specific task.

\paragraph{Devices}
In the Meadow system, a \textcolor{blue2}{\bf{}device} is an {\em
  programmable\/} entity which provides a set of services to the outside
world. In particular, a device provides three different types of services:
{\em native functions\/}, {\em 
  properties}, and {\em events}. A device is a notion which typically
represents a family of physical devices, such as ``Apple iPhone 5''. However,
as long as a software entity has its service interface defined in Meadow IDL,
it can be considered as a Meadow device. For example, an Oracle
database server, whose functionality is exported through the Meadow system is
considered as a Meadow device.


A \textcolor{blue2}{\bf{}native function} is a predefined function provided by
a device (e.g. a LED banner can display messages on the banner screen). 
Properties and events are data items, which support different use models.
A \textcolor{blue2}{\bf{}property} can be read and rewritten by other devices
on demand. Such activities are initiated by the consumers of the data --
i.e. the communication is demand driven (a.k.a. pull model).
An \textcolor{blue2}{\bf{}event} is a data item which can be only
read and such activity is initiated by the producer of the data -- i.e. the
communication is data driven (a.k.a. push model). 
In particular, an event represents that ``something, which may be of interest
to others, has happened''.\footnote{The notion of events differentiate the
Meadowview language from other typical programming languages. This
facilitates the event-driven programming model, which is probably the 
most adequate programming model for distributed systems. FOr example, in the
EDA (Electronic Design Automation) industry has long been using }

%% This language can be used to filter, transform, and generate events. 
%% The language was designed mostly for the analysis and generation of
%% events. Therefore, it lacks common programming language features such as
%% recursion. We expect all 
%% compute-intensive tasks will be performed at the endpoints in the overall
%% universe of events. Upon an arrival of an event instance, a Meadowview
%% program  defines what new events needs to be generated as a result of
%% evaluating rules  that react to the event.

\paragraph{Workflows}
A \bb{workflow} is a well-defined piece of work to be performed by a set of
devices. A workflow consists of {\em reactive processes\/}, which gets
activated whenever some specific set of events occurs.
%% A device can have many instances and each device instance can contain
%% {\em reactive processes}.\footnote{Note that device instances, not devices,
%%   can contain reactive processes. The ``iPod Nano 5th generation model'' is a
%%   device in MV parlance and ``the iPod Nano 5th generation owned by Jason'' is
%%   a device instance.\/}. 
A \bb{reactive process} is a computational entity which, upon
the receipt of events, to which the process is sensitized to, 
perform computation, such as:
%A \bb{primitive operation} is one of the following:
\bit
\w general computation -- e.g. basic operations, assignments, branching,
  loops 
\w access to a property (local or nonlocal)
\w invocation of a native function (local or nonlocal)
\w generation of an event
\w waiting for an event
\eit
%A behavior of a device instance is determined by the set of processes that it
%contains at the given time. 



\section{Devices}
A \bb{device} is an entity, which is characterized by the set of
native functions, properties, and events it provides to the outside world. 
Each device has a globally-unique name -- i.e. no two devices have the 
same name. 

As an example, a 24-hour fitness club, located in San Jose, has
purchased 50 Samsung TVs. To maintain these TVs, a developer can define
a new device named \verb+com.24.sj.tv.samsung+.
Each of the 50 TVs can be registered as instances of
\verb+com.24.sj.tv.samsung+.
See below for \bb{interface definition} of a device --  definitions of native
functions, properties, events will be added in later paragraphs.
\begin{verbatim}
  device com.24.sj.tv.samsung {
    // native function definition
    // property definition
    // event definition
  }
\end{verbatim}
Through a registration interface to the Meadow system, this name will be
registered to a global device name server.

\subsection{Native functions}
A \bb{native function} of a device represents a native capability provided 
by the device. It is self-contained, without any dependence on other devices 
to accomplish the functionality.
Consider the \verb+com.24.sj.tv.samsung+ device we created.
This device can support
multiple functions, such as turning on and off the screen, and switching the
channel. Each such function is describe by a function signature. 
As an example:
\begin{alltt}
  device com.24.sj.tv.samsung \{
    // native function definition
    \textbf{void turnOn();
    void turnOff(); 
    void switchChannel(input int channel);}

    // property definition
    // event definition
  \};
\end{alltt}
One important thing is that these functions should have been already added 
in  the target backend framework. For example, when AllJoyn
framework is used as a backend, three AllJoyn methods should exist that
corresponds to the above three functions. In particular, the MV expects
that the device should already contain three AllJoyn methods named
\verb+turnOn+, \verb+turnOff+, and  \verb+switchChannel+.  
In case ZeroMQ is
used as a backend, ZeroMQ based  
code was already added, which can communicate using some predefined MV method
invocation protocol (including the message format).\footnote{To support various
  backends, we have to define such message format. We can either use XML or
  JSON as the basis.}



%% One important thing is that \verb+int+ which indicates that \verb+channel+
%% argument should be an integer is not forced during compilation. The specifier
%% \verb+int+ is only a hint to the MV developer that that it is expected to pass
%% integer to the function \verb+switchChannel+. 
%% MV is a dynamically-typed language and type checking will be performed during
%% run time. 


\subsection{Properties}
A device can have properties, which are named data items.
These properties can be read and written by local or nonlocal processes.
Considering the TV device again, it can have the following properties:
\begin{alltt}
  device com.24.sj.tv.samsung \{
    // native function definition
    void turnOn();
    void turnOff(); 
    void switchChannel(input int channel);

    // property definition
    \textbf{int channel;     // current channel
    int status;      // 0: turned off, 1: turned on}

    // event definition
  \};
\end{alltt}
The meaning that a device, \verb+com.24.sj.tv.samsung+, contains a 
property, named \verb+channel+, means that, for any instance of this device,
other device instances can access its \verb+channel+ property.
The set of datatypes, which properties can have, will be discussed in a later
section. 

\subsection{Events}
An event of a device represents a data item which is created when something
related to the device has happened. Such data items will be delivered only to
the {\em subscribers\/} of the event. Note that the data delivery occurs in
asynchrony with the operation of subscribers. If device instance $A$ wants to
subscribe an event, $e$,
generated by device instance $B$, a process must be defined in $B$ which is
sensitive to this event. Then, whenever $B$ creates an {\em instance\/} of
event $e$, the process will be awakened and executed.
Processes will be discussed in detail in a later
section. Defining a process, which is sensitive to an event, say $e$, is
  the only way to make a device instance to subscribe to the event $e$.

Events can be classified into two types of events: {\em built-in events\/} and
{\em user-defined events\/}. A built-in event is one which is automatically
included to any device. For example, \verb+signOnEvent+ and
\verb+signOffEvent+, which are generated when a device instance has signed on
to (or signed off from) the Meadow system.\footnote{A natural or extensible
  way to model built-in event is to define a ``root'' event and let
  user-defined events be subclasses of the root event. Should we support the
  notion of classes?}
\begin{alltt}
  device com.24.sj.tv.samsung \{
    // native function definition
    void turnOn();
    void turnOff(); 
    void switchChannel(input int channel);

    // property definition
    int channel;             // current channel
    int status;              // 0: turned off, 1: turned on

    // event definition
    \textbf{event turnOnEvent;       // generated when turned on
    event turnedOffEvent;    // generated when turned off
                             // - these events have no payload

    event channelSwitched \{  // generated when channel switched
      int oldChannel;        // - this event has payload
      int newChannel;
    \};}
  \};
\end{alltt}
Note that events are an essential mechanism for schedule some activity in 
distributed computation. While we know exactly when each operation will happen 
 in a single-threaded application, in distributed computation, sometimes we
 don't know when some computation will be finished and the next computation
 can be resumed. So, we are forced to schedule activities in a passive
way as callbacks to events. 

\subsection{Interface definition of devices}\label{sec:devdef}
To introduce a new device (actually, a new class of device instances) into the
Meadow system, the device must be defined in the Meadowview language. Only
after a device is defined, its instances can be defined. 
\begin{verbatim}
  device com.24.sj.tv.samsung {
    // native functions
    void turnOn();
    void turnOff(); 
    void switchChannel(input int channel);

    // properties
    int channel;
    int status;
   
    // events
    event turnOnEvent;
    event turnedOffEvent;
    event channelSwitched { 
      int oldChannel; 
      int newCchannel;
    };
  };

\end{verbatim}
Thie definition is used to \bb{register} a device named
named \verb+com.24.sj.tv.samsung+ to the globally-maintained device name
server.

\subsection{Instantiation of devices}
A device can have many instances -- e.g. 50 instances
the device \verb+com.24.sj.tv.samsung+.
Any instance of this device provides the functionality as defined 
in its device definition (e.g. one defined in Section~\ref{sec:devdef}.
As an example, if a device variable which is bound to an instance of
\verb+com.24.sj.tv.samsung+, will 
accept \verb+turnOn()+ function call.\footnote{One can think of a device as a
  {\em C++ class\/}, while its instance can be
thought of as a {\em object\/} of the class.}

One important issue is {\em how we can assign a unique name to each device
instance\/}. In MV, an instance of a device \verb+devname+ will be denoted by
a name of the form \verb+devname[instname]+.  For example,
\verb+com.24.sj.tv.samsung[2F.10]+, may denote a TV located in the 2nd 
floor of 24 hour fitness San Jose club. Without a unqiue name of a device
instance, we cannot route the service request to a particular device instance.

\paragraph{Registration of device instance names}
Now, the question is how we can assign the name to each device instance.
This can be achieved on a single assumption. Each device instance, regardless
of whose instance it is, has a unqiue ID. Then, the problem of assigning a
device instance name becomes a registration of device instance name-to-unique
ID mapping.  Whenever a device signs on to the Meadow system, it sends the
unique ID. Then, since the Meadow system knows that the device with the given
ID has been assigned a particular device instance name, any service request
directed to the given device instance can be routed to the given device
instance. 


\paragraph{Lifetime of devices and device instances}
Both device and device instance are persistent entities which are created,
updated, and deleted through special registration interface to the Meadow
system. The Meadowview compiler will generate code which will use some
interfaces to the Meadow system.
When created, the device persists until it is explicitly deleted. 
A device cannot be deleted as long as there is at least one device instance.
A device instance is also a persistent entity which is created, updated, and
deleted through special registration. 

%A device instance becomes activated inside the Meadow
%system when it signs on to the Meadow system. 


\section{Workflows}
A \bb{workflow} is a well-defined piece of work to be performed by a set of
devices. A workflow can be defined in MV, paramerized by a set of roles, which 
will later be enacted by actual device instances.

\subsection{Definition of workflows}
A workflow is defined with devices as its parameters.
Each workflow has a globally-unique name.
%  worfklow com.mv.test.flow(list<com.apple.ipod.nano> devs)
\begin{verbatim}
  worfklow com.mv.test.flow(com.24.sj.tv.samsung tvs[], 
                            com.24.sj.tv.maserremote remote)
  {
    // process void is a process which is executed once 
    // when the given workflow is instantiated;
    process init(/*empty events*/) {
      db = :getDeviceByName("com.24.sj.db");
      db.log(:getTime(), "workflow instantiated");
    };

    // c.f. for-generate 
    foreach tv in tvs {
      process P(tv:signOnEvent()) {
        ...
      };

    };

    // when a "turnOffAll" button of the master remote control
    // is pushed, turn of all TVs
    process turnOffAllTvs(remote:turnOffAllEvent()) {
      for (int i = 0; i < tvs.size(); i++) { 
        tv = tvs[i];
        tv.turnOff();
      }
    };
  };
\end{verbatim}


\subsection{Processes}
A process is a code fragment, which consists of two parts:
{\em event sensitivity\/} and {\em process body\/}. 
An \bb{event sensitivity} is an expression of events, 
to which the process is
sensitive to. A \bb{process body} consists executable statements.
As an example,
\begin{verbatim}
  process P(com.24.sj.tv.samsung[2F.10]:turnOnEvent e) {
    // process body which will be executed whenever the event
    // turnOnEvent of the given device instance is generated;
    // the event instance will bound to e, allowing the process
    // to read the data of the event instance

    // :getDeviceInstanceOf is a built-in function which is 
    // supported by the Meadow system itself (not by a device)
    Device db = :getDeviceInstanceOf("com.24hour.dbsvr");
    db.log(e.devinst, e.time, "TV turned on");
  };
\end{verbatim}
More details will be discussed in Section~\ref{sec:proc}.


\subsection{Instantiation of workflows}
A workflow can be executed when it is instantiated with actual device
instances. There are different models a workflow is instantiated: single
execution and recurrent execution. 

\paragraph{Single execution model}
When all processes defined in a workflow is non-reactive processes (i.e. event
sensitivity is empty), instantiation of the workflow will be executed once at
the time of instantiation. No processes will be actually deployed to device
instances. 

\paragraph{Recurrent execution model}
All reactive processes (processes with non-empty sensitivity list) we have
permanent behavior until this workflow is deleted.


\paragraph{Workflows and processes}
Inclusion of a process in a workflow means that, when the workflow is
deployed to device instances, these device instances will begin to have 
reactive behavior as defined in the process.

\subsection{Hierarchy of workflows}
\begin{verbatim}
  worfklow com.mv.test.subflow(com.24.sj.tv.samsung devs[])
  {
    process p() {
      ...
    };
  };

  worfklow com.mv.test.topflow (com.24.sj.tv.samsung devs[]) {
    com.mv.test.subflow sub(devs);
  };
\end{verbatim}

\subsection{Merger of workflows}
Workflow definitions can be connected to form a bigger workflow.
This is accomplished by adding a pseudo device, whose role is to connect
workflows.\footnote{Similar to interfaces in SystemVerilog?} 

\section{Processes}\label{sec:proc}
Definition of a new process over devices introduces a new coordination
behavior over the corresponding devices.
A process is a code fragment, which consists of two parts:
{\em event sensitivity\/} and {\em process body\/}. 
An \bb{event sensitivity} is an expression of events, 
to which the process is
sensitive to. A \bb{process body} consists executable statements.
As an example,
\begin{verbatim}
  process P(com.24.sj.tv.samsung[2F.10]:turnOnEvent e) {
    // process body which will be executed whenever the event
    // turnOnEvent of the given device instance is generated;
    // the event instance will bound to e, allowing the process
    // to read the data of the event instance

    // :getDeviceInstanceOf is a built-in function which is 
    // supported by the Meadow system itself (not by a device)
    Device db = :getDeviceInstanceOf("com.24hour.dbsvr");
    db.log(e.devinst, e.time, "TV turned on");
  };
\end{verbatim}
Whenever the event sensitivity evaluates to true, the process is
activated. 

%% The following is another example, which initializes the channel to 
%% 10 whenever an instance of device \verb+com.24.sj.tv.samsung+ turns
%% on.
%% \begin{verbatim}
%%   process P(com.24.sj.tv.samsung:turnOnEvent e) {
%%     Device dev = e.devinst;
%%     dev.chanel = 10;
%%   };
%% \end{verbatim}

%% \subsection{Event sensitivity}
%% An event is a special type of data items, which cannot be accessed directly by 
%% the consumer. An event can have many instances and an event instance is
%% produced by a device instance. 
%% Consider the following device definition, which models the Safari web browser,
%% from which a person will create an order to an Internet store.
%% \begin{verbatim}
%%   device com.apple.safari {
%%     string clientId;

%%     event OrderEvent {
%%       int productId;
%%       int quantity;
%%     };
%%   }
%% \end{verbatim}
%% The name of the event is \verb+com.apple.safari.OrderEvent+ and this event
%% name is unique in the entire event name space of the Meadow system. This
%% uniqueness is a natural consequence of uniqueness of device names.
%% An instance of the event \verb+com.apple.safri.OrderEvent+ can only be 
%% generated by an instance of the device \verb+com.apple.safari+. 

%% Let \verb+com.appleid.cj2005.safari+ be the name of a device instance.
%% Then, the event instance of \verb+OrderEvent+ generated by
%% \verb+com.appleid.cj2005.safari+ has the name
%% \begin{verbatim}
%%   com.appleid.cj2005.safari.OrderEvent
%% \end{verbatim}
%% Note that there many exist many such event instances of this name since the
%% given device instance many generated many such event instances. To avoid any
%% ambiguity, each event instances will internally contain a {\em serial
%%   number\/}. 

%% Every event will contain the following default fields
%% \begin{verbatim}
%%   DeviceInstance devinst;
%%   int serial;
%%   int event;
%%   Time time;
%% \end{verbatim}


\subsection{Event sensitivity} 
An {\em event sensitivity\/} is an expression which specifies under which
condition the given process gets executed. The following forms of expressions
are supported:
\bit
\w \bb{empty event}: When the event sensitivity list is empty, it means that
  the process is not reactive but will be executed only once at the time when
  the workflow which contains the process is instantiated. 

  Processes with empty event sensitivity can be used to define behavior which
  is not specific to any device instance. For example, if we want to store
  some log information to a DB server whenever the given workflow is
  instantiated. 
  \begin{verbatim}
  process P() {
    Device dbserver = getDeviceByName("com.24.sj.dbserver");
    dbserver.log("workflow has been instantiated");
  };
  \end{verbatim}

\w \bb{primitive event}: a fully-qualified constant event
  \begin{verbatim}
  proces P(com.24.sj.tv.samsung[2F.10]:turnOnEvent e) {
    Device smtp = getDeviceByName("com.24.sj.smtp");
    smtp.sendmail("jason@live.com", "title", "body");
  };
  \end{verbatim}
%% The prefix can be a device instance variable, as in
%%   \begin{verbatim}
%%   variable.turnOnEvent e
%%   \end{verbatim}
\w \bb{disjunction of events}: The process will wake up when at least one of
the given event instances happen.
  \begin{verbatim}
  process P(com.24.sj.tv.samsung[2F.10]:turnOnEvent e1 or
            com.24.sj.tv.samsung[2F.11]:turnOnEvent e2) {
    ...
  }
  \end{verbatim}

\w \bb{conjunction of events}: The process will wake up when both event
instances happen. This is a way how ``join'' behavior is
modeled.\footnote{There're some technical issues. What if {\tt{}e1} arrives
  100 times but no {\tt{}e2} event has happened yet. Should we queue all
  100 instances of the {\tt e1} event? This would cause some ``internal
  queue'' to be filled up, eventually requiring us to drop some unconsumed
  event instances.  We could give some timeout to each event instance to
  handle this. 
  Or, we can restrict that any conjunction should be between
  events which have the same source -- i.e. which are caused by the same
  event. } 
  \begin{verbatim}
  process P(com.24.sj.tv.samsung[2F.10]:turnOnEvent e1 and
            com.24.sj.tv.samsung[2F.11]:turnOnEvent e2) {
    ...
  }
  \end{verbatim}
\eit

\section{Values}
The values that can be represented in MV are listed below.
%% Variables can be defined and used in MV. 
%% MV is a dynamically-typed language, meaning that the datatypes are associated
%% with values (unlike statically-typed languages, where datatypes are associated
%% with variables). Variables can be bound to any values. 
%% A value can contain one of the following datatypes.
\bit
\w \bb{boolean}: \verb+true+ and \verb+false+
\w \bb{integer}: \verb+100+, \verb+-10+, etc
\w \bb{real}: \verb+10.34+, \verb+10.0+, \verb+10.5E-10+, etc.
\w \bb{string}: \verb+"hello"+
\w \bb{character}: \verb+'c'+
\w \bb{time}: \verb+!2014/2/14/14:00.54+
\w \bb{array}: \verb+[1, 2, 3]+
\w \bb{structure}: \verb+{2, "string", [1, 2, 3]}+
\w \bb{device instance}: \verb+#com.24.sj.tv.samsung[2F.10]+
\w \bb{event instance}: \verb+#com.24.sj.tv.samsung[24.10]:turnedOnEvent+
 Device instances are first-class citizens in the Meadowview language in the
  sense that they can be assigned to variables, passed as function arguments,
  and can be return values of a function.
\eit

\section{Expressions}

\section{Statements}
\subsection{Variable definition}
\begin{verbatim}
  device dev = :getDeviceInstanceOf("com.precor.sj.treadmill");
  int intval = 5;
\end{verbatim}

\subsection{Branching}
\begin{verbatim}
  if (a == 10)
    dev.switchChannel(10);
  else
    dev.switchChannel(5);

  switch (a) {
  case 10: 
    dev.switchChannel(10);
  default: 
    dev.switchChannel(5);
  }
\end{verbatim}

\subsection{Loops}
\begin{verbatim}
  for (i = 0; i < 10; i++)
    dev.switchChannel(i);    
\end{verbatim}

\subsection{Event wait}
\begin{verbatim}
  @(com.24.sj.tv.samsung[]:channelSwitchedEvent e);
\end{verbatim}

\subsection{Event generation}
\begin{verbatim}
  -> com.24.sj.tv.samsung[]:channelSwitchedEvent(10 /*old*/, 11 /*new*/);
\end{verbatim}

\subsection{Native function call}
\begin{verbatim}
  dev.switchChannel(i);    
\end{verbatim}

\subsection{Function definition}
Should we allow (non-native) function definition and calls?
Maybe in the next version?



\section{Built-in Functions}
\subsection{Device location}
\bit
\w \verb+:getDeviceInstanceByName(input string name)+
\eit


\section{Example: Treadmill Example}

\tableofcontents

%\bibliographystyle{plain}
%\bibliography{bib/mac,bib/softsys,bib/compsys,bib/digital,bib/pl}
\end{document}

%%  LocalWords:  MeadowView EPL Hadoop proc FSM API insertEvent TCP IP ev MV
%%  LocalWords:  Runtime workflow lookup Namespace stateful Meadow Jeong VM
%%  LocalWords:  Cheoljoo runtime HDLs Verilog VHDL HDL APIs softsys compsys
x
%%  LocalWords:  workflows iPhone getID getOwnerName printMsg msg pairDevice
%%  LocalWords:  resetStepCount getStepCount dev TODO isPaired deviceFound tm
%%  LocalWords:  startButtonPressed stopButtonPressed healthcare addStepCount
%%  LocalWords:  userid stepcount SecureID AllJoyn Qualcomm ZeroMQ Bluetooth
%%  LocalWords:  ZigBee WiFi ethernet CoAP iOS MacOS Andriod IPC JNI OLED pre
%%  LocalWords:  MessageQueue Meadowview loadProcess unloadProcess procid th
%%  LocalWords:  Precor Samsung iPod Nano nonlocal datatypes asynchrony
%%  LocalWords:  signOnEvent signOffEvent turnOn OrderEvent There're boolean
%%  LocalWords:  backend turnOff switchChannel backends SystemVerilog
