\chapter{Logic and Calculi for Specifying Properties}

\section{Computation Tree Logic CTL*}

\subsection{Computation tree}
A CTL* formula describes a property of  computation trees. 
A computation tree is formed by designating a state in a Kripke 
structure as the {\em initial state} and then unwinding the 
structure into an infinite tree with the designated state as the root.
A node of a computation tree is a state of the Kripke structure
reachable from the initial state through a sequence of valid transitions.
The computation tree shows all possible executions starting from the
initial state

\subsection{Path quantifiers and temporal operators}
CTL* formulas are composed of {\em path quantifiers} and 
{\em temporal operators}. Path quantifiers describe the {\em branching
  structure} in the computation tree. 
These quantifiers are used in a particular state to specify that all of the
paths or some of paths {\em starting from that state\/} have some property.
    \bit
    \w \bb{A}: for all computation paths
    \w \bb{E}: for some computation path
    \eit
Temporal operators describe the properties of a ``path'' throughout
the tree. 
    \bit
    \w \bb{X} (``next time''): holds in the second state of the path
    \w \bb{F} (``eventually'' or ``in the future''): will hold at some state
    on the path 
    \w \bb{G} (``always'' or ``globally''): holds at every state on the path
    \w \bb{U} (``until''): holds if there is a state on the path where the
    second property holds, and at every preceding state on the path, the first
    property holds
    \w \bb{R} (``release''): the second property holds along the path up to
    and including the first sate where the first property holds; however, the
    first property is not required to hold eventually
    (logical dual of \bb{U} operator)
    \eit
\subsection{CTL* formulas}
Two types of CTL* formulas exist: {\em state formulas\/} (which are true in a
specific state) and {\em path formulas} (which are true along a specific
path). Let $AP$ be a set of atomic proposition names.
The syntax of state formulas in CTL* is defined as follows:
      \bit
      \w if $p \in AP$, then $p$ is a state formula
      \w if $f$ and $g$ are state formulas, then $\neg f$,\  $f \vee g$,\ $f
      \wedge g$ are state formulas
      \w if $f$ is a path formula, then \bb{E} $f$ and \bb{A} $f$ are state
      formulas 
      \eit
The syntax of path formulas in CTL* is defined using two additional rules
given below: 
      \bit
      \w if $f$ is a state formula, then $f$ is also a path formula
      \w if $f$ and $g$ are path formulas, then $\neg f$,\ $f \vee g$,\ 
      $f \wedge g$,\ \bb{X} $f$, \bb{F} $f$,\ \bb{G} $f$,\ $f$ \bb{U} $g$,
      and $f$ \bb{R} $g$ are path formulas
      \eit
CTL* is the set of state formulas generated by the above rules.


\subsection{Semantics of CTL*}
The semantics of CTL* is defined with respect to a Kripke structure.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modal Logic}
\noindent{}A modal logic is any system of formal logic that attempts to deal
with {\em modalities}. Traditionally, there are three {\em modes\/} or 
{\em moods\/}: \bb{possibility}, \bb{probability}, and \bb{necessity}. 
Logics for dealing with a number of related terms, such as ``eventually'',
``formerly'', ``can'', ``could'', ``might'', ``may'', ``must'', are by
extension also called model logics, since it turns out that these can be
treated in similar ways. 

\subsection{Modal operators}
A model logic represents modalities using modal operators. 
For example, ``Jones's murder was a possibility'', ``Jones was possibly
murdered'', and ``It is possible that Jones was murdered'' all contain 
the notion of possibility. In a modal logic this is represented as an
operator, {\em Possibly\/}, attaching to the sentence ``Jones was murdered.''

The basic 1-place modal operators are usually written $\Box{}$ (or $L$)
for {\em Necessarily} and $\Diamond{}$ (or $M$) for {\em Possibly}. 
In a classical modal logic, each can be expressed by the other and negation.
\begin{eqnarray*}
  \Diamond P & \Leftrightarrow & \neg\box\neg P, \\
  \Box P & \Leftrightarrow & \neg\Diamond\neg P
\end{eqnarray*}
Thus it is possible that Jones was murdered if and only if it is not necessary
that Jones was not murdered. 

\subsection{Kripke semantics}
The standard formal semantics of the basic
modal language is Kripke semantics.
Kripke semantics (also known as {\em relational semantics\/} or 
{\em frame semantics\/}, and often confused with {\em possible world
  semantics\/}) is a formal semantics for 
non-classical logic systems created in the late 1950s and early 1960s by Saul
Kripke, beginning when he was a teenager. It was first made for modal logics,
and later adapted to intuitionistic logic and other non-classical systems. The
discovery of Kripke semantics was a breakthrough in the making of
non-classical logics, because the model theory of such logics was nonexistent
before Kripke.
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modal $\mu$-calculus}
The modal $\mu$-calculus is a class of temporal logics with a \bb{least fixed
  point operator} $\mu$. It is used to describe properties of labeled
transition systems and for verifying these properties.
Many temporal logics, including LTL, CTL, CTL*, can be enoded in the
$\mu$-calculus. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dynamic Logic}
Dynamic logic is an extension of modal logic originally intended for reasoning
about complex beahviors of processes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linear Logic}


