\documentclass{myart}
\usepackage{theorem,mydef}
\begin{document}

\title{\large\bf Operating Systems; Sample Problems and Solutions}
\author{\normalsize Cheoljoo Jeong}
\date{}
\maketitle

%%%
\section{Memory Management}
\bit
\w \bb{Paging}: lets the logical address space of a process to be
	\bb{noncontiguous}
	\bit
	\w physical memory $\ra$ \bb{frames}
	\w logical memory $\ra$ \bb{pages}
	\w \bb{internal fragmentation}
	\eit
\w paging separates the user's view of the memory and the actual physical
	memory
\w \bb{frame table}: \bb{free-frame list}
\w \bb{page table}: per-process object
	\bit
	\w paging increases context-switch time
	\w page table is usually kept in a \bb{main memory} $\ra$ problem!
		$\ra$ TLB
	\w \bb{PTBR} points to page table
	\eit
\w \bb{TLB}: \bb{associative register}
\w \bb{hit ratio}: percentage of times that a page number is found
	in the TLB
	\bit
	\w \bb{hit time}: 
		\ben	
		\w TLB lookup time
		\w actual memory access time
		\een
	\w \bb{non-hit time}:
		\ben
		\w TLB lookup time
		\w page table access time
		\w actual memory access time	
		\een
	\eit
\w \bb{effective access time}: hit ratio $p$
	\bit
	\w p $\ \times\ $ hit-time + (1-p) $\ \times\ $ non-hit-time
	\eit
\w \bb{protection}:
	\bit
	\w \bb{protection bit} for every \bb{frame}
		\bit
		\w read-only page \& read-write page
		\eit
	\w \bb{valid-invalid bit} for every page table entry
		\bit
		\w ``valid'' indicates that the associated page is in the 
		process's logical address space $\ra$ ``legal''
		\eit
	\eit
\w \bb{multilevel paging}
	\bit
	\w page number ($p_1, p_2$) + offset $(d)$
	\eit
\w \bb{inverted page table}
	\bit
	\w drawbacks of page tables:
	``{\em{}each page table may consists of millions of entries!\/}''
	\w inverted page table has \bb{one entry for each real frame
		of physical memory}
	\w decreases the amount of memory for each page table;
	but increases the amount of time needed to search the table
	when page reference occurs
	\eit
\eit


\section{Virtual memory}
\bit
\w \bb{Effective access time}
	\bit
	\w \bb{Page fault rate}: $0 \le p < 1$
	\w EAT = $(1 - p)\ \times\ $(memory access) + 
		$p\ \times\ $(page fault overhead)
	\w page fault overhead: swap out time + swap in time
	\eit
	
\w There are $m$ initially empty page frames and the page-reference
	string has length $p$; $n$ distinct page numbers occur in it.
	\bit
	\w lower bound on the number of page faults:
	min$\{m, n\}$
	\w upper bound on the number of page faults: $p$
	\eit
\w virtual memory space of $2^{32}$ bytes. $2^{18}$ bytes of 
	physical memory.
	page size is $4,096$ bytes. user process generates
	the virtual address $11123456$. how does the system generate
	the physical location.
	\begin{quote}
	virtual address: 32 bit = 20 + 12 for (page number, page offset)\\
	physical address: 18 bit = total 64 page frames in phyical memory
	\end{quote}
\w which is good for demand-paged environment
	\bit
	\w \bb{stack}:	
	\w \bb{hash symbol table}: 
	\w \bb{sequential search}: BAD; a memory location accessed would
		won't be accessed again
	\w \bb{binary search}:
	\w \bb{pure code}: GOOD; locality
	\w \bb{vector operations}:
	\w \bb{indirection}:
	\eit
\eit











\end{document}
% LocalWords:  endpoint Fulkerson Bellman mac sys inet

